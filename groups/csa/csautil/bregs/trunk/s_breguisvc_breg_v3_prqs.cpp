#include <s_breguisvc_breg_v3_prqs.h>
#include <s_breguisvc_helpers_v3.h>

#include <bael_log.h>

#include <prqs_approver_api.h>

#include <bbit/200612/prqs_control_self_approval.h>
#include <bbit/201207/bbit_breguisv_notify_grabber.h>

#include <pvf_checkprvl.h>

#include <systemdate.h>
#include <dbutil.h>

#include <prqs_machines_api.h>

extern "C"
{
#include <host_api.h>
#include <nextseed.h>
#include <prqs_api.h>
#include <prqs.h>
#include <prqsdb.h>
#include <prqs_new_out_tree_wrapper.h>
#include <prqs_rc_api.h>
#include <prqs_api.h>
#include <prqs_update_associated_ticket.h>
#include <prqs_approver_api.h>
#include <prqsutil.h>
#include <prqs_covg_api.h>
#include <prqs_special_pvf_check.h>
#include <empldb_wrappers.h>
#include <getuuidname_w.h>
#include <grabber_util.h>
void msecofday_(int *msec);
}

using namespace std;

namespace BloombergLP {
namespace s_breguisvc {
namespace bregv3prqs {

namespace {
int createPrqsWithLimitPriv(prqs_registry_record *prqs_rec,
                            const BregChangeRequest& request,
                            int version);
int validatePrqsRcRecord(prqs_registry_record *prqs_rec);
int isValidApprover(int prqs_type,
                                    int prog_uuid, int approver_uuid,
                                    int check_lockdown, int priority);
int addPrqsInfoRecord(prqs_registry_record *prqs_record,
                      int *status,
                      int *creation_time,
                      int *creation_date);
int addPrqsRcRecord(prqs_registry_record *prqs_record,
                    int creation_time,
                    int creation_date);
int addPrqsRaRecord(prqs_registry_record *prqs_record,
                    int creation_time,
                    int creation_date);
int createPrqsLog(int prqs_number, int prqs_time, int prqs_date,
                  int prog_uuid,
                  int log_lines,
                 char log_msg[PRQS_REGISTRY_NUM_LOG_LINES][PRQS_REGISTRY_LOG_LINE_LEN]);
/* Code uses this function is commented out, remove it once confirmed!!!
bool hasPrqsRcLimitPrivilege(const BregChangeRequest& request,
                                 int uuid);
bool bregPrqsCanAccessMachines(int *machlist, int machine_count,
                               prqsct_special_pvf special_pvf_rec);
bool isOverrideChanged(
    int *machines,
    int *machine_count,
    int max_machine_count,
    const vector<bregv3db::EntryOverride>& oldOverrides,
    const vector<bregv3db::EntryOverride>& newOverrides
);
bool isOverrideSequenceChanged(
    const vector<bregv3db::EntryOverride>& oldOverrides,
    const vector<bregv3db::EntryOverride>& newOverrides
);
*/
bool isSpeedupPropagate(const BregChangeRequest& request, int version);
int getMachineCountInOverride(int machine_id);
void sendMessage(prqs_registry_record *prqs_record, 
                 char *funcname,
                 int status);
}


int createPrqs(int *prqsNo, const BregChangeRequest& request, 
                int version, int uuid, int event)
{
    BAEL_LOG_SET_CATEGORY("createPrqs");

    int entryId = request.registry().entry().value().entryId();

    // set prqs_rec
    prqs_registry_record prqs_rec;

    prqs_rec.prqs_type = PRQS_REGISTRY_CHANGE;
    snprintf(prqs_rec.description, PRQS_REGISTRY_DESC_LEN, "BREG %d: %s", 
             entryId, request.registry().node().name().c_str());
    prqs_rec.prog_uuid = uuid;
    snprintf(prqs_rec.version_no, sizeof(prqs_rec.version_no), "%d", version);
    prqs_rec.approver_uuid = request.approverUuid();
    prqs_rec.registry_id = entryId;

    std::string tktType;
    bool isDrqsType = false;
    if (request.entryValue().auditRecord().ticketType() == 44) {
        tktType = "DRQS ";
        isDrqsType = true;
    }
    else if (request.entryValue().auditRecord().ticketType() == 45)
        tktType = "TREQ ";
    else if (request.entryValue().auditRecord().ticketType() == 46)
        tktType = "SYMV ";

    std::ostringstream oss, ossDiff;
    oss << "Autogenerated PRQS for {FIFW " << tktType 
        << request.entryValue().auditRecord().ticketNumber()
        << "<GO>}" << endl << ends;


    int start_line = 0;
    if (version > 0) {
        try {
            bregv3db::DbAccessor db;
            int curVersion = db.getBackoutVersion(entryId, version);
            BAEL_LOG_DEBUG << entryId << " curVers " << curVersion
                       << " new version " << version << BAEL_LOG_END;
            if (curVersion < version) {
                ossDiff << "Diff from previous version: "
                    << "{FIFW BREG " << entryId 
                    << " DIFF " << curVersion << " " << version
                    << " <GO>}" << ends;
            }
        } catch (bregv3db::DbException& e) {
           BAEL_LOG_INFO << e.what() << BAEL_LOG_END;
        }
        ++start_line;
    }

    string logs = request.entryValue().auditRecord().logNote();
    int logLen = logs.length();
    int num_lines = (logLen + PRQS_REGISTRY_LOG_LINE_LEN - 1) / 
                                    (PRQS_REGISTRY_LOG_LINE_LEN-1);

    int log_note_count = 1;
    snprintf(prqs_rec.log_msg[0], PRQS_REGISTRY_LOG_LINE_LEN,
             "%s", oss.str().c_str());
    if (start_line) {
        snprintf(prqs_rec.log_msg[start_line], PRQS_REGISTRY_LOG_LINE_LEN,
             "%s", ossDiff.str().c_str());
        ++log_note_count;
    }

    BAEL_LOG_DEBUG << "num_lines: " << num_lines
                   << ", start_line: " << start_line
                   << BAEL_LOG_END;

    for (int i=0; i<num_lines && log_note_count<PRQS_REGISTRY_NUM_LOG_LINES; ++i)
    {
        string logLine = logs.substr(i * (PRQS_REGISTRY_LOG_LINE_LEN-1));
        snprintf(prqs_rec.log_msg[log_note_count], PRQS_REGISTRY_LOG_LINE_LEN,
                 "%s", logLine.c_str());

        BAEL_LOG_DEBUG << "log line " << log_note_count << ": "
                       << prqs_rec.log_msg[log_note_count] << BAEL_LOG_END;
        ++log_note_count;
    }

    prqs_rec.num_log_lines = log_note_count;
    prqs_rec.priority = request.prqsPriority();
    prqs_rec.covg_required = request.covgRequired();

    int rc;
    switch (event) {
    case RELEASE_CODE_PRQS:
        // create PRQS ticket
        rc = prqs_registry_release_ticket_create(&prqs_rec);
        if (PRQS_REGISTRY_NO_ERROR != rc) {
            BAEL_LOG_ERROR << "prqs_registry_release_ticket_create: rc "
                           << rc << BAEL_LOG_END;
            return rc;
        }
        break;
    case PROD_CHANGE_PRQS:
        BAEL_LOG_DEBUG << "create prod value change PRQS: " << entryId
                       << BAEL_LOG_END;
        rc = createPrqsWithLimitPriv(&prqs_rec, request, version);
        if (PRQS_REGISTRY_NO_ERROR != rc) {
            BAEL_LOG_ERROR << "createPrqsWithLimitPriv: rc "
                           << rc << BAEL_LOG_END;
            return rc;
        }
        break;
    default:
        BAEL_LOG_ERROR << "unknown event: " << event << BAEL_LOG_END;
        return PRQS_REGISTRY_DB_UNDEFINED_ERROR;
    }

    *prqsNo = prqs_rec.prqs_number;
    BAEL_LOG_DEBUG << "created PRQS: " << *prqsNo << BAEL_LOG_END;

    if(isDrqsType) {
        int ticket_rc = prqs_update_associated_ticket(
                             PRQS_TICKET_TYPE_DRQS,
                             request.entryValue().auditRecord().ticketNumber(),
                             prqs_rec.prog_uuid,
                             prqs_rec.prqs_number,
                             entryId, PRQS_TICKET_TYPE_CREATE);
        if(ticket_rc != PRQS_UPDATE_TICKET_NO_ERROR &&
           ticket_rc != PRQS_UPDATE_TICKET_OFF) {
            
            BAEL_LOG_INFO << "prqs_update_associated_ticket failed. rc=" 
                          << ticket_rc << ", drqs="
                          << request.entryValue().auditRecord().ticketNumber() 
                          << ", uuid=" << prqs_rec.prog_uuid
                          << ", prqsnum=" << prqs_rec.prqs_number
                          << ", bregid=" << entryId
                          << BAEL_LOG_END;
        }
    }

    return PRQS_REGISTRY_NO_ERROR;
}


namespace {

int createPrqsWithLimitPriv(prqs_registry_record *prqs_rec,
                            const BregChangeRequest& request,
                            int version)
{
    BAEL_LOG_SET_CATEGORY("createWithLimitPriv");

    if (!prqs_rec) {
        BAEL_LOG_ERROR << "null input" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }

    //we can only run on prqs machine, or dev/test machines
    int current_host = machine();
    if (is_prqs_machine(current_host, 0) == PRQS_API_INVALID_MACHINE && 
        prqs_validate_devmachine(current_host) &&
        prqs_validate_testmachine(current_host)) {
        BAEL_LOG_DEBUG << "wrong host for PRQS " << current_host
                       << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_MACHINE;
    }

    int rc;
    if ( (rc = validatePrqsRcRecord(prqs_rec)) )
        return rc;

    int check_lockdown = 1;
    //if (prqs_rec->version_no[0] != '0')
        //check_lockdown = 1;
    if (request.registry().entry().value().apiStatus() != ApiStatus::RELEASED)
        check_lockdown = 0;

    rc = isValidApprover(prqs_rec->prqs_type,
                         prqs_rec->prog_uuid, prqs_rec->approver_uuid,
                         check_lockdown, prqs_rec->priority);
    if (rc != PRQS_REGISTRY_NO_ERROR) {
        BAEL_LOG_DEBUG << "failed on approval validation" << BAEL_LOG_END;
        return rc;
        /* this code is useless as there is no prqs rc special privilege setup
        if (hasPrqsRcLimitPrivilege(request, prqs_rec->approver_uuid)) {
            BAEL_LOG_DEBUG << "has rc_limit_priv" << BAEL_LOG_END;
        }
        else {
            BAEL_LOG_DEBUG << "failed on approval validation" 
                           << BAEL_LOG_END;
            return rc;
        }
        */
    }

    int creation_date, creation_time;
    int status = A;
    accprqs_Tstart();
    if ((rc = addPrqsInfoRecord(prqs_rec,
                                &status,
                                &creation_time,
                                &creation_date)) != PRQS_REGISTRY_NO_ERROR) {
        BAEL_LOG_DEBUG << "fail to add prqs record" << BAEL_LOG_END;
        accprqs_Trollback();
        return rc;
    }

    // add rc or ra request depends
    if (prqs_rec->prqs_type == PRQS_REGISTRY_CHANGE){
        if ( (rc = addPrqsRcRecord(prqs_rec, creation_time, creation_date)) ) {
            BAEL_LOG_DEBUG << "fail to add prqs rc" << BAEL_LOG_END;
            accprqs_Trollback();
            return rc;
        }
    }
    else if (prqs_rec->prqs_type == PRQS_REGISTRY_ABORT){
        if ((rc = addPrqsRaRecord(prqs_rec, creation_time, creation_date))){
            BAEL_LOG_DEBUG << "fail to add prqs ra" << BAEL_LOG_END;
            accprqs_Trollback();
            return rc;
        }
    }

    // add log_msg passed from the breg/prqs functions
    createPrqsLog(prqs_rec->prqs_number,
                  creation_time,
                  creation_date,
                  prqs_rec->prog_uuid,
                  prqs_rec->num_log_lines,
                  prqs_rec->log_msg);

    // set local log msg to blanks
    char log_msg[PRQS_REGISTRY_NUM_LOG_LINES][PRQS_REGISTRY_LOG_LINE_LEN];
    for (int i = 0;i < PRQS_REGISTRY_NUM_LOG_LINES;++i)
        memset(log_msg[i],0,PRQS_REGISTRY_LOG_LINE_LEN);
  
    // init the log_msg with an auto  msg
    char api_func[] = "BREG";
    snprintf(log_msg[1],PRQS_REGISTRY_LOG_LINE_LEN,
             " ~~~~ This request was automatically generated by %s function",
             api_func);

    // add log with a time increamented by 1 to avoid dup on add error
    createPrqsLog(prqs_rec->prqs_number,
                  creation_time+1,
                  creation_date,
                  prqs_rec->prog_uuid,
                  2,
                  log_msg);
    rc = accprqs_Tcommit();
    if (rc) {
        BAEL_LOG_DEBUG << "failed on accprqs_Tcommit()" << BAEL_LOG_END;
        return rc;
    }

    // update prqs fs queue 
    //update_fs_queue(registry_ticket->prqs_number,registry_ticket->prog_uuid);
  
    bool speedup = isSpeedupPropagate(request, version);

    BAEL_LOG_DEBUG << prqs_rec->prqs_number << " speedup " << speedup
                   << BAEL_LOG_END;

    if (bbit_breguisv_notify_grabber__value() || status != A) {
        BAEL_LOG_INFO << prqs_rec->prqs_number << " notify farmer of status "
                      << status << BAEL_LOG_END;
        if (prqs_rec->prqs_type == PRQS_REGISTRY_CHANGE && speedup) {
            grbr_send_prqs_status_update(prqs_rec->prqs_number, status,
                                         GRBR_STFG_RESET_STATUS_NQ);
        }
        else
            // notify grabber about new request
            change_prqs_status_contents(prqs_rec->prqs_number,status);
    }

    // finally send a message
    sendMessage(prqs_rec, api_func, status);

    return PRQS_REGISTRY_NO_ERROR;
}

int validatePrqsRcRecord(prqs_registry_record *prqs_rec)
{
    BAEL_LOG_SET_CATEGORY("validatePrqsRcRecord");

    if (!prqs_rec){
        BAEL_LOG_DEBUG << "null input" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }

    // validate prqs type
    if (prqs_rec->prqs_type != PRQS_REGISTRY_CHANGE &&
        prqs_rec->prqs_type != PRQS_REGISTRY_ABORT &&
        prqs_rec->prqs_type != PRQS_REGISTRY_DV_REQUEST) {
        BAEL_LOG_DEBUG << "null prqs_type: " << prqs_rec->prqs_type
                       << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }  
 
    // validate uuids and trmv/gtmv  numbers
    if (prqs_rec->prog_uuid <= 0 || prqs_rec->approver_uuid <= 0) {
        BAEL_LOG_DEBUG << "invalid uuids: prog " << prqs_rec->prog_uuid
                       << " approver " << prqs_rec->approver_uuid
                       << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }
 
    // validate number of log lines passed
    if (prqs_rec->num_log_lines < 0 || 
        prqs_rec->num_log_lines > PRQS_REGISTRY_NUM_LOG_LINES) {
        BAEL_LOG_DEBUG << "wrong number of log lines" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }
  
    // validate uuids
    const int PRQS_REGISTRY_NAME_LEN = 30;
    char tmpname[PRQS_REGISTRY_NAME_LEN];  
    if (getuuidname(tmpname,PRQS_REGISTRY_NAME_LEN,prqs_rec->prog_uuid) ||
        tmpname[0] == '*' ||
        getuuidname(tmpname,PRQS_REGISTRY_NAME_LEN,
                    prqs_rec->approver_uuid) || tmpname[0] == '*') {
        BAEL_LOG_DEBUG << "invalid uuids: prog " << prqs_rec->prog_uuid
                       << " approver " << prqs_rec->approver_uuid
                       << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }

    // make sure the description is entered
    char blanks[PRQS_REGISTRY_DESC_LEN];
    memset(blanks,' ',PRQS_REGISTRY_DESC_LEN);
    if (!strlen(prqs_rec->description) || 
        !strncmp(prqs_rec->description,blanks,
                 strlen(prqs_rec->description))) {
        BAEL_LOG_DEBUG << "invalid description" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }

    // validate version 
    if (!strlen(prqs_rec->version_no) ||
        !strncmp(prqs_rec->version_no, blanks,
                 strlen(prqs_rec->version_no))) {
        BAEL_LOG_DEBUG << "invalid version" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }

    // validate registry id
    if (prqs_rec->registry_id <= 0) {
        BAEL_LOG_DEBUG << "invalid registry_id " << prqs_rec->registry_id
                       << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }

    for (int i=prqs_rec->num_log_lines; i < PRQS_REGISTRY_NUM_LOG_LINES; 
         ++i)
        prqs_rec->log_msg[i][0] = '\0';
 
    return PRQS_REGISTRY_NO_ERROR;
}

int isValidApprover(int prqs_type,
                    int prog_uuid, int approver_uuid,
                    int check_lockdown, int priority)
{
    BAEL_LOG_SET_CATEGORY("isValidApprover");

    BAEL_LOG_DEBUG << "prqs_type " << prqs_type << " prog_uuid "
                   << prog_uuid << " approver_uuid " << approver_uuid
                   << " check_lockdown " << check_lockdown << " priority "
                   << priority << BAEL_LOG_END;

    char err_msg[PRQS_APPROVER_API_ERR_MSG_LEN+1];
  
    prqs_approver_api_rc rc = PRQS_APPROVER_API_ERROR;

    if (prqs_type == PRQS_REGISTRY_ABORT)
        rc = is_prqs_ra_approver_and_group_same(prog_uuid,
                                                approver_uuid, 
                                                err_msg,
                                           PRQS_APPROVER_API_ERR_MSG_LEN+1);
    else if (prqs_type == PRQS_REGISTRY_CHANGE)
        rc = is_prqs_rc_approver_and_group_same(prog_uuid,
                                                approver_uuid, 
                                                check_lockdown,
                                                err_msg,
					   PRQS_APPROVER_API_ERR_MSG_LEN+1);
    else if (prqs_type == PRQS_REGISTRY_DV_REQUEST)
        rc = is_prqs_dv_approver_and_group_same(prog_uuid,
                                                approver_uuid, 
                                                err_msg,
					   PRQS_APPROVER_API_ERR_MSG_LEN+1);

    if (rc == PRQS_APPROVER_API_IS_APPROVER && 0 == priority)
        rc = is_prqs_priority_0_approver(approver_uuid,
                                         err_msg,
                                         PRQS_APPROVER_API_ERR_MSG_LEN+1);

    BAEL_LOG_DEBUG << "approver check rc " << rc << BAEL_LOG_END;

    if (rc == PRQS_APPROVER_API_IS_APPROVER)		 
        return PRQS_REGISTRY_NO_ERROR;
    else
        return PRQS_REGISTRY_INVALID_APPROVER;
}

int addPrqsInfoRecord(prqs_registry_record *prqs_record,
                      int *status,
                      int *creation_time,
                      int *creation_date)
{
    BAEL_LOG_SET_CATEGORY("addPrqsInfoRecord");

    if (!prqs_record || !status || !creation_time || !creation_date){
        BAEL_LOG_DEBUG << "null input" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }
    
    // get unique request number.
    int dbnum = 3346, seed[2];
    int rcode = nextseed(dbnum, seed);         
    if (rcode != 0){
        BAEL_LOG_DEBUG << "nextseed error: rc " << rcode << BAEL_LOG_END;
        return static_cast<prqs_registry_rcode>(PRQS_REGISTRY_DB_UNDEFINED_ERROR+rcode);
    }

    prqs_record->prqs_number = seed[1];

    // set group for the user
    empldb_rec_t empl_rec;
    char emsg[81];
    if ((rcode = empldb_find_idx15keyl4(prqs_record->prog_uuid,
                                        &empl_rec,
                                        emsg, sizeof(emsg)))) {
        BAEL_LOG_DEBUG << "empldb_find error: " << emsg << BAEL_LOG_END;
        return (PRQS_REGISTRY_DB_UNDEFINED_ERROR+rcode);
    }

    // zero out future fields
    PRQS_BUFzero(0, PRQS_BUFSZB); 
  
    // if switch for use_new_out_tree() is on,
    // then use new method to get dept id.    
    if (prqs_to_use_new_out_tree() == 1) {
        int group = 0;
        int subgroup = 0;
        if (prqs_set_grp_sgrp_ids_by_uuid(prqs_record->prog_uuid,
                                          &group, &subgroup)!=0)
            BAEL_LOG_DEBUG << "set_grp_sgrp_ids_by_uuid failed for "
                           << prqs_record->prog_uuid << BAEL_LOG_END;
        PRQS_GROUP_settor(group);
        PRQS_SUBGROUP_settor(subgroup);
    }
    else {
        PRQS_GROUP_settor(empl_rec.dept_chain[4]);
        PRQS_SUBGROUP_settor(empl_rec.dept_chain[5]);
    }

    *creation_date = systemdate();
    msecofday_((int *)(creation_time));

    short ttype, tsubtype;
    prqs_api_rq_type2type(prqs_record->prqs_type, &ttype, &tsubtype);

    PRQS_TYPE_settor(ttype);
    PRQS_SUBTYPE_settor(tsubtype);
    PRQS_UUID_PROG_settor(prqs_record->prog_uuid);
    PRQS_UUID_MGR_settor(prqs_record->approver_uuid);
    PRQS_UUID_OP_settor(0);
    PRQS_UUID_ASSIGN_settor(0);
    PRQS_PRIORITY_settor(prqs_record->priority);
    if (prqs_record->prog_uuid == prqs_record->approver_uuid) {
        int ct[32];
        int num_entries = 0;
        int disable_self_approval = 0;
        int pos;
        // check for disable self-approval
        if (prqs_control_self_approval__rc(ct, &num_entries,
                                           sizeof(ct)/sizeof(int))) {
            switch(ct[0]) {
            case 0: 
                break;
            case 1:
                disable_self_approval = 1;
                break;
            case 2:
                for (pos = 2; pos < num_entries; pos++)
                    if (prqs_record->prqs_type == ct[pos]) { 	
                        disable_self_approval = 1;
                        break;
                    }
                break;
            default:
                disable_self_approval = 0;
            }
        }

        // pvf level 108 will be allowed self-approval no matter what
        prqsFlag_et validateUuid = static_cast<prqsFlag_et>(0);
        char func[] = "PRQS";
        if (prqs_pvf_checkprvl(func, 108, prqs_record->approver_uuid, 
                               validateUuid))
            disable_self_approval = 0;

        if(disable_self_approval) {
            *status = A;
        }  
        else {
            if ((int)prqs_record->prqs_type == (int)PRQS_RC)
                *status = S;
            else
                *status = S;
        }
    }
    else
        *status = A;

    PRQS_STATUS_settor(*status);
    PRQS_BUCKET_TYPE_settor(get_prqs_bucket_type(prqs_record->prqs_type,0,
                                                 PRQS_STATUS));
    PRQS_BUCKET_STATUS_settor(get_prqs_bucket_status(PRQS_STATUS));
    PRQS_BUCKET_VIEW_settor(get_prqs_bucket_view(PRQS_BUCKET_TYPE,
                                                 PRQS_BUCKET_STATUS));
    PRQS_DESCRIPTION_settorP(prqs_record->description, PRQS_DESCRIPTION_LEN);

    int prqs_ret = accprqs_add(MACC_ADD, PRQS_INFO_RCD, 
                               prqs_record->prqs_number,
                               *creation_date, *creation_time);

    if (prqs_ret != 0){
        BAEL_LOG_DEBUG << "error adding rc=" << prqs_ret << " rqnum="
                       << prqs_record->prqs_number << BAEL_LOG_END;
        if (prqs_ret == 102 || prqs_ret == 103 || prqs_ret == 999)
            return PRQS_REGISTRY_DB_UNAVAILABLE;
        else if(prqs_ret == 2)
            return PRQS_REGISTRY_ADD_DUPLICATE;
        else
            return(prqs_ret + PRQS_REGISTRY_DB_UNDEFINED_ERROR);
    }

    return PRQS_REGISTRY_NO_ERROR;
}


int addPrqsRcRecord(prqs_registry_record *prqs_record,
                    int creation_time,
                    int creation_date)
{       
    BAEL_LOG_SET_CATEGORY("addPrqsRcRecord");

    if (!prqs_record) {
        BAEL_LOG_DEBUG << "null input" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }
    
    // zero out future fields 
    PRQS_BUFzero(0, PRQS_BUFSZB); 
    
    // set info for rc rec
    PRQS_RC_REG_ENTRY_ID_settor(prqs_record->registry_id);
    PRQS_RC_VERSION_NO_settorP(prqs_record->version_no, 
                               PRQS_RC_VERSION_NO_LEN);

    if(prqs_record->covg_required)
        PRQS_RC_COVGREQUIRED_settor(1);
    else
        PRQS_RC_COVGREQUIRED_settor(0);
    
    int prqs_ret = accprqs_add(MACC_ADD, PRQS_RC, prqs_record->prqs_number, 
                               creation_date, creation_time);
  
    if (prqs_ret != 0) {
        BAEL_LOG_DEBUG << "fail to add prqs rc=" << prqs_ret
                       << "rqnum=" << prqs_record->prqs_number
                       << BAEL_LOG_END;
        if (prqs_ret == 102 || prqs_ret == 103 || prqs_ret == 999)
            return PRQS_REGISTRY_DB_UNAVAILABLE;
        else if (prqs_ret == 2)
            return PRQS_REGISTRY_ADD_DUPLICATE;
        else
            return (prqs_ret + PRQS_REGISTRY_DB_UNDEFINED_ERROR);
    }
  
    // add record to COVG
    if (prqs_record->covg_required) {
        prqs_covg_api_rcode rc_covg = 
            prqs_register_covg(prqs_record->prqs_number);
        if (rc_covg!=PRQS_COVG_API_NO_ERROR) {
            BAEL_LOG_DEBUG << "prqs_register_covg failed:prqsnum="
                           << prqs_record->prqs_number << " rc="
                           << rc_covg << BAEL_LOG_END;
        }
    }

    return PRQS_REGISTRY_NO_ERROR;
}

int addPrqsRaRecord(prqs_registry_record *prqs_record,
                    int creation_time,
                    int creation_date)
{
    BAEL_LOG_SET_CATEGORY("addPrqsRaRecord");

    if (!prqs_record) {
        BAEL_LOG_DEBUG << "null input" << BAEL_LOG_END;
        return PRQS_REGISTRY_INVALID_ARGS;
    }

    // zero out future fields
    PRQS_BUFzero(0, PRQS_BUFSZB);

    // set info for rc rec
    PRQS_RA_REG_ENTRY_ID_settor(prqs_record->registry_id);
    PRQS_RA_VERSION_NO_settorP(prqs_record->version_no, 
                               PRQS_RA_VERSION_NO_LEN);
    int prqs_ret = accprqs_add(MACC_ADD, PRQS_RA, 
                               prqs_record->prqs_number, 
                               creation_date, creation_time);
  
    if (prqs_ret != 0) {
        BAEL_LOG_DEBUG << "fail to add prqs rc=" << prqs_ret
                       << "rqnum=" << prqs_record->prqs_number
                       << BAEL_LOG_END;
        if (prqs_ret == 102 || prqs_ret == 103 || prqs_ret == 999)
            return PRQS_REGISTRY_DB_UNAVAILABLE;
        else if (prqs_ret == 2)
            return PRQS_REGISTRY_ADD_DUPLICATE;
        else
            return (prqs_ret + PRQS_REGISTRY_DB_UNDEFINED_ERROR);
    }

    return PRQS_REGISTRY_NO_ERROR;
}

#if 0
bool hasPrqsRcLimitPrivilege(const BregChangeRequest& request,
                             int approverUuid)
{
    BAEL_LOG_SET_CATEGORY("hasPrqsRcLimitPrivilege");

    int entryId = request.registry().entry().value().entryId();
    bregv3db::EntryValue oldValue;
    bregv3db::Audit audit;
    
    try {
        bregv3db::DbAccessor db;
        int version = db.getCurrentProdVersion(entryId);
        db.getProdEntryValue(&oldValue, &audit, entryId, version);
    }
    catch (bregv3db::DbException& e) {
       BAEL_LOG_ERROR << e.what() << BAEL_LOG_END;
       return false;
    }

    bregv3db::EntryValue newValue;
    int valueType = request.registry().entry().value().valueType();
    helpers_v3::svcValueToDbValue(&newValue, request.entryValue(), 
                                  valueType);
 
    if (oldValue.entryData().isNull() || newValue.entryData().isNull())
        return false;

    // if default value is changed, return false
    if (oldValue.entryData() != newValue.entryData()) {
        BAEL_LOG_DEBUG << entryId << " default value changed" << BAEL_LOG_END;
        return false;
    }

    // check if overrides are changed
    // if non-machine override is changed or no change, return
    // if machine override is changed, then check if the user has privilege
    int machines[50];
    int machine_count = 0;
    if (!isOverrideChanged(machines, &machine_count,
                           sizeof(machines)/sizeof(int),
                           oldValue.entryOverrides(),
                           newValue.entryOverrides())) {
        BAEL_LOG_DEBUG << entryId << " no override change" << BAEL_LOG_END;
        return false;
    }

    if (machine_count < 1) {
        BAEL_LOG_DEBUG << entryId << " machine_count " << machine_count
                       << BAEL_LOG_END;
        return false;
    }

    // if machine value changed, and check if the uuid has prqs rc limit
    // privilege if yes return TRUE: ok to save
    int num_recs = 0;
    prqsct_spec_rec_prim_key prqs_pvf_keys[20];
    prqsct_rc ct_rc = get_list_of_prqsct_spec_recs_by_type_sub(PRQS_RC, 
                                                               0, 0, 20,
                                                               &num_recs,
                                                               prqs_pvf_keys);
    BAEL_LOG_DEBUG << "get_list_of_prqsct_spec_recs_by_type_sub entry "
                   << entryId << " ct_rc " << ct_rc << " num_recs "
                   << num_recs << BAEL_LOG_END;
    if (ct_rc || num_recs < 1)
        return false;

    for (int i=0; i<num_recs; i++) {
        int rcode;
        char errmsg[81] = {0};
        int priv = pvf_checkprvl_new("PRQS",
                                     (bbint32_t)prqs_pvf_keys[i].pvf_level,
                                     approverUuid,
                                     &rcode, errmsg, strlen("PRQS"), 
                                     sizeof(errmsg));
        if (!priv)
            continue;

        prqsct_special_pvf special_pvf_rec;
        char filename[] = "ALL";
        if (!prqs_has_special_approval(PRQS_RC, 0, prqs_pvf_keys[i].pvf_level,
                                       filename, &special_pvf_rec))
            continue;

        // if mach number/group is in special_pvf_rec.allowed_nodes
        // get all the list changed machines
        if (bregPrqsCanAccessMachines(machines, machine_count, 
                                      special_pvf_rec))
            return true;
    }

    // default can not be saved
    return false;
}
#endif

bool isSpeedupPropagate(const BregChangeRequest& request, int version)
{
    BAEL_LOG_SET_CATEGORY("isSpeedupPropagate");

    const int BREG_SPEEDUP_MAX_MACHNUM = 10;

    int entryId = request.registry().entry().value().entryId();
    bregv3db::EntryValue oldValue;
    bregv3db::Audit audit;
    
    try {
        bregv3db::DbAccessor db;
        int curVersion = version;
        int oldVersion = db.getBackoutVersion(entryId, curVersion);
        BAEL_LOG_DEBUG << entryId << " curVers " << curVersion
                       << " oldVers " << oldVersion << BAEL_LOG_END;
        db.getProdEntryValue(&oldValue, &audit, entryId, oldVersion);
    }
    catch (bregv3db::DbException& e) {
       BAEL_LOG_ERROR << e.what() << BAEL_LOG_END;
       return false;
    }

    bregv3db::EntryValue newValue;
    helpers_v3::svcValueToDbValue(&newValue, request.entryValue(), 
                                  request.registry().entry().value().valueType());

    // check if default value is changed
    if ( (oldValue.entryData().isNull() && !newValue.entryData().isNull()) ||
         (!oldValue.entryData().isNull() && newValue.entryData().isNull()) )
        return false;

    if ( (!oldValue.entryData().isNull() && !newValue.entryData().isNull()) && 
         (newValue.entryData().value() != oldValue.entryData().value()) ) {
        BAEL_LOG_DEBUG << "No Speedup (default value change): " << entryId
                       << BAEL_LOG_END;
        return false;
    }

    // check overrides
    const vector<bregv3db::EntryOverride>& oldOverrides = 
        oldValue.entryOverrides();
    const vector<bregv3db::EntryOverride>& newOverrides = 
        newValue.entryOverrides();
        
    int affected_machine = 0;
    int oldCount = oldOverrides.size();
    int newCount = newOverrides.size();
    int index = 0;

    BAEL_LOG_DEBUG << "entry: " << entryId << " old_override_count="
                   << oldCount << " new_override_count=" << newCount
                   << BAEL_LOG_END;

    bool isMachOvrdIdChanged = false;

    while (oldCount > 0 || newCount > 0) {

        if (oldCount <= 0 || newCount <= 0) { // only one list has element
            bregv3db::EntryOverride ovrd;
            if (oldCount <= 0)
                ovrd = newOverrides[index];

            if (newCount <= 0)
                ovrd = oldOverrides[index];

            if (ovrd.overrideType() != 
                bregv3db::DbAccessor::MACHINE_OVERRIDE) {
                BAEL_LOG_DEBUG << "No Speedup (non-mach-override): " << entryId
                               << " ovrdtype " << ovrd.overrideType()
                               << BAEL_LOG_END;
                return false;
            }
            int machcount = 
                getMachineCountInOverride(ovrd.overrideTypeValue());
            BAEL_LOG_DEBUG << "override machcount: " << entryId
                           << " " << machcount << BAEL_LOG_END;
            if (machcount <= 0) {
                BAEL_LOG_DEBUG << "No Speedup (machcount): " << entryId
                               << " machcount " << machcount << BAEL_LOG_END;
                return false;
            }
            affected_machine += machcount;
        }
        else { // all lists have elements
            bregv3db::EntryOverride oldOvrd = oldOverrides[index];
            bregv3db::EntryOverride newOvrd = newOverrides[index];

            // override type changed
            if (oldOvrd.overrideType() != newOvrd.overrideType())
                return false;

            // override type value changed
            if (oldOvrd.overrideTypeValue() != newOvrd.overrideTypeValue()) {
                if (newOvrd.overrideType() != 
                    bregv3db::DbAccessor::MACHINE_OVERRIDE)
                    return false;

                isMachOvrdIdChanged = true;

                int machcount = 
                    getMachineCountInOverride(oldOvrd.overrideTypeValue());
                if (machcount <= 0) {
                    BAEL_LOG_DEBUG << "No Speedup (machcount): " << entryId
                                   << " machcount " << machcount
                                   << BAEL_LOG_END;
                    return false;
                }
                affected_machine += machcount;
                    
                machcount = 
                    getMachineCountInOverride(newOvrd.overrideTypeValue());
                BAEL_LOG_DEBUG << "override machcount: " << entryId
                               << " " << machcount << BAEL_LOG_END;
                if (machcount <= 0) {
                    BAEL_LOG_DEBUG << "No Speedup (machcount): " << entryId
                                   << " machcount " << machcount
                                   << BAEL_LOG_END;
                    return false;
                }
                affected_machine += machcount;
            }
            else {
                /* found non-machine override with same ovrd_id. and,
                   machine ovrd_id was changed before, this has potential
                   effect on no-machine overrides, return false */
                if (isMachOvrdIdChanged && 
                    newOvrd.overrideType() != 
                    bregv3db::DbAccessor::MACHINE_OVERRIDE)
                    return false;

                if (oldOvrd.entryData().value() != 
                    newOvrd.entryData().value()) {
                    
                    if (newOvrd.overrideType() != 
                        bregv3db::DbAccessor::MACHINE_OVERRIDE)
                        return false;

                    int machcount = 
                        getMachineCountInOverride(newOvrd.overrideTypeValue());
                    BAEL_LOG_DEBUG << "override machcount: " << entryId
                                   << " " << machcount << BAEL_LOG_END;
                    if (machcount <= 0) {
                        BAEL_LOG_DEBUG << "No Speedup (machcount): " << entryId
                                       << " machcount " << machcount
                                       << BAEL_LOG_END;
                        return false;
                    }
                    affected_machine += machcount;   
                }
            }
        }

        if (affected_machine > BREG_SPEEDUP_MAX_MACHNUM)
            return false;

        ++index;
        --newCount;
        --oldCount;
    }

    BAEL_LOG_DEBUG << "entry " << entryId << " affected_machine "
                   << affected_machine << BAEL_LOG_END;
        
    if (affected_machine > 0 && affected_machine <= BREG_SPEEDUP_MAX_MACHNUM)
        return true;

    return false;
}

int getMachineCountInOverride(int machine_id)
{
    const int MAX_MACHIINE_NUMBER = 2048;
    const int MACH_NAME_LENGTH = 65;
    char machine_name[MACH_NAME_LENGTH];
    int  nodes[2];
    int  ids[MAX_MACHIINE_NUMBER];
    int  rnids=0;
    int  rcode=-1;

    if(machine_id<=0)
        return 0;

    memset(machine_name, 0, sizeof(machine_name));
    /* check if it is single machine */
    host_rc rc = host_get_machine_name_from_id(machine_id, machine_name, 
                                               sizeof(machine_name));
    if (rc == HOST_RC_OK)
        return 1;

    memset(machine_name, 0, sizeof(machine_name));
    /* check if it is a machine group */
    rc = host_get_group_name_from_id(machine_id, machine_name, 
				      sizeof(machine_name));
    if (rc != HOST_RC_OK)
        return 0;

    const int PRQS_BRDEV_MACH_GRP = 10257;

    nodes[0] = machine_id;
    nodes[1] = -PRQS_BRDEV_MACH_GRP;
    rcode = prqs_get_machine_ids(nodes, 2, ids, MAX_MACHIINE_NUMBER, &rnids);
    if(rcode || rnids<1)
        return 0;

    return rnids;
}

#if 0
bool isOverrideChanged(
    int *machines,
    int *machine_count,
    int max_machine_count,
    const vector<bregv3db::EntryOverride>& oldOverrides,
    const vector<bregv3db::EntryOverride>& newOverrides)
{
    if (!machines || max_machine_count < 1)
        return false;

    if (isOverrideSequenceChanged(oldOverrides, newOverrides))
        return false;

    bool foundMatch = false;
    bool machineOvrdChanged = false;
    int oldOvrdCount = oldOverrides.size();
    int newOvrdCount = newOverrides.size();

    int mindex = 0;
    int oindex = 0;   
    int nindex = 0;
    while (oindex < oldOvrdCount) {
        bregv3db::EntryOverride oldOvrd = oldOverrides[oindex];
        while (nindex < newOvrdCount) {
            bregv3db::EntryOverride newOvrd = newOverrides[nindex];

            if (oldOvrd.overrideType() == newOvrd.overrideType() &&
                oldOvrd.overrideTypeValue() == newOvrd.overrideTypeValue()) {
                foundMatch = true;
                break;
            }
            ++nindex;
        }

        if (!foundMatch) {
            if (oldOvrd.overrideType() != 
                bregv3db::DbAccessor::MACHINE_OVERRIDE)
                return false;
            
            machineOvrdChanged = true;
            machines[mindex++] = oldOvrd.overrideTypeValue();
        }
        ++oindex;
    }

    /* find machine overrides only in new machine list (newly added machine
       overrides), and machine overrides that exist in both list and
       override values are changed (values changed machine overrides) */

    nindex = 0;
    while (nindex < newOvrdCount) {
        bregv3db::EntryOverride newOvrd = newOverrides[nindex];

        foundMatch = false;
        oindex = 0;
        while (oindex < oldOvrdCount && !foundMatch) {
            bregv3db::EntryOverride oldOvrd = oldOverrides[oindex];

            if (oldOvrd.overrideType() == newOvrd.overrideType() &&
                oldOvrd.overrideTypeValue() == newOvrd.overrideTypeValue()) {
                foundMatch = true;
                if (oldOvrd.entryData() != newOvrd.entryData()) {
                    if (newOvrd.overrideType() != 
                        bregv3db::DbAccessor::MACHINE_OVERRIDE)
                        return false;
                    machineOvrdChanged = true;
                    machines[mindex++] = newOvrd.overrideTypeValue();
                }
            }
            ++oindex;
        }

        if (!foundMatch) {
            if (newOvrd.overrideType() !=
                bregv3db::DbAccessor::MACHINE_OVERRIDE)
                return false;
            
            machineOvrdChanged = true;
            machines[mindex++] = newOvrd.overrideTypeValue(); 
        }

        ++nindex;
    }

    *machine_count = mindex;
    return machineOvrdChanged;
}

bool isOverrideSequenceChanged(
    const vector<bregv3db::EntryOverride>& oldOverrides,
    const vector<bregv3db::EntryOverride>& newOverrides)
{
    int oldOvrdCount = oldOverrides.size();
    int newOvrdCount = newOverrides.size();
    if (oldOvrdCount <= 0 || newOvrdCount <= 0)
        return false;

    int oindex = 0;
    int nindex = 0;
    while (oindex < oldOvrdCount && nindex < newOvrdCount) {
        bregv3db::EntryOverride oldOvrd = oldOverrides[oindex];
        bregv3db::EntryOverride newOvrd = newOverrides[nindex];
        if (oldOvrd.overrideType() == bregv3db::DbAccessor::MACHINE_OVERRIDE) {
            ++oindex;
            continue;
        }
        if (newOvrd.overrideType() == bregv3db::DbAccessor::MACHINE_OVERRIDE) {
            ++nindex;
            continue;
        }

        if (oldOvrd.overrideType() != newOvrd.overrideType() ||
            oldOvrd.overrideTypeValue() != newOvrd.overrideTypeValue())
            return true;

        ++oindex;
        ++nindex;
    }

    int nonMachOld = 0;
    int nonMachNew = 0;
    // check remaining old overrides
    while (oindex < oldOvrdCount) {
        bregv3db::EntryOverride oldOvrd = oldOverrides[oindex];
        if (oldOvrd.overrideType() == 
            bregv3db::DbAccessor::MACHINE_OVERRIDE) {
            ++oindex;
            continue;
        }

        ++nonMachOld;
        ++oindex;
    }

    // check remaining new overrides
    while (nindex < newOvrdCount) {
        bregv3db::EntryOverride newOvrd = newOverrides[nindex];
        if (newOvrd.overrideType() == 
            bregv3db::DbAccessor::MACHINE_OVERRIDE) {
            ++nindex;
            continue;
        }

        ++nonMachNew;
        ++nindex;
    }

    if (nonMachOld != nonMachNew)
        return true;

    return false;
}

bool bregPrqsCanAccessMachines(int *machlist, int machine_count,
                               prqsct_special_pvf special_pvf_rec)
{    
    if (!machlist || machine_count <= 0)
        return false;

    bool can_access = false;

    for (int j = 0; j < machine_count; ++j) {
      
        for (int i = 0; i < special_pvf_rec.num_machines; i++) {
            short node_id = machlist[j];
            short allowed_node_id = special_pvf_rec.allowed_nodes[i];

            // if the machine isn't in the special record
            if (allowed_node_id != node_id && 
                !(is_prqs_machine_group(allowed_node_id) != ERROR &&
                  check_node_in_group(node_id, allowed_node_id) != ERROR) && 
                check_if_subset_of_allowed_super_group(node_id, 
                                                       allowed_node_id)) {
                can_access = false;
            }
            else {
                can_access = true;
                break;
            }
        }

        if (!can_access)
            return false;
    }

    return can_access;
}
#endif

int createPrqsLog(int prqs_number, int prqs_time, int prqs_date,
                  int prog_uuid,
                  int log_lines,
                  char log_msg[PRQS_REGISTRY_NUM_LOG_LINES][PRQS_REGISTRY_LOG_LINE_LEN])
{
    BAEL_LOG_SET_CATEGORY("createPrqsLog");

    int prqs_ret;

    if (prqs_number<=0 || prqs_time<=0 || prqs_date<=0 || prog_uuid<=0)
        return PRQS_REGISTRY_INVALID_ARGS;
  
    if(log_lines == 0)
        return PRQS_REGISTRY_NO_ERROR;

    char blanks[PRQS_REGISTRY_LOG_LINE_LEN];
    memset(blanks,' ',PRQS_REGISTRY_LOG_LINE_LEN);

    bool log_empty = true;
    for (int i=0;i<PRQS_REGISTRY_NUM_LOG_LINES;i++)
        if(strncmp(log_msg[i],blanks,PRQS_REGISTRY_LOG_LINE_LEN) && 
           strncmp(log_msg[i],blanks,strlen(log_msg[i])))
            log_empty = false;
    if (log_empty)
        return PRQS_REGISTRY_NO_ERROR;
 
    PRQS_UUID_AUTHOR_settor(prog_uuid);
  
    for (int i=0; i < 5; i++)
        PRQS_LOG_NOTES_settorP(i, log_msg[i], PRQS_LOG_NOTES_LEN);
  
    prqs_ret = accprqs_add(MACC_ADD, PRQS_LOG_RCD, prqs_number, 
                           prqs_date, prqs_time);

    if (prqs_ret != 0) {
        BAEL_LOG_DEBUG << "failed to add prqs log rc=" << prqs_ret
                       << " rqnum=" << prqs_number << BAEL_LOG_END;  
        if (prqs_ret == 102 || prqs_ret == 103 || prqs_ret == 999)
            return PRQS_REGISTRY_DB_UNAVAILABLE;
        else if (prqs_ret == 2)
            return PRQS_REGISTRY_ADD_DUPLICATE;
        else
            return (prqs_ret + PRQS_REGISTRY_DB_UNDEFINED_ERROR);
    }

    return PRQS_REGISTRY_NO_ERROR;
}

void sendMessage(prqs_registry_record *prqs_record,
                 char *funcname, int status)
{
    BAEL_LOG_SET_CATEGORY("sendMessage");

    char message[PRQS_UTIL_MSG_LINES][PRQS_UTIL_MSG_LINE_LEN];
    int to_uuid[PRQS_UTIL_MSG_RECIPIENTS];
    char msg_line[PRQS_UTIL_MSG_LINE_LEN+1];
    short rcode;

    if(!funcname || !prqs_record)
        return;

    for (int i = 0;i < PRQS_UTIL_MSG_RECIPIENTS;i++)
        to_uuid[i] = 0;

    //set the uuid of the person to receive the msg
    to_uuid[0] = prqs_record->approver_uuid;

    // don't send duplicate messages
    if(prqs_record->approver_uuid!=prqs_record->prog_uuid)
        to_uuid[1] = prqs_record->prog_uuid;

    for (int i = 0;i < PRQS_UTIL_MSG_LINES; i++)
        memset(message[i],0,PRQS_UTIL_MSG_LINE_LEN);

    // create the message to be sent
    if (status == A)
        snprintf(msg_line,PRQS_UTIL_MSG_LINE_LEN+1,
                 "PRQS %d awaiting Approval (generated from %s)",
                 prqs_record->prqs_number, funcname);
    else
        snprintf(msg_line,PRQS_UTIL_MSG_LINE_LEN+1,
                 "PRQS %d was Approved (generated from %s)",
                 prqs_record->prqs_number, funcname);
 
    strncpy(message[0], msg_line,
            MIN(strlen(msg_line),PRQS_UTIL_MSG_LINE_LEN));

    snprintf(message[1], PRQS_UTIL_MSG_LINE_LEN,"Description: %s\n\n",
             prqs_record->description);

    snprintf(message[2], PRQS_UTIL_MSG_LINE_LEN,
             "This request was autogenerated by %s function.\n\n", funcname);
  
    snprintf(message[3],PRQS_UTIL_MSG_LINE_LEN+1, 
             "Thank you for using PRQS.\n");

    /* send the msg */ 
    rcode = prqs_send_message(prqs_record->prqs_number,
                              prqs_record->prog_uuid, 
                              to_uuid, message);
    if (rcode)
        BAEL_LOG_DEBUG << "fail to send a msg rc " << rcode
                       << " prqs " << prqs_record->prqs_number 
                       << BAEL_LOG_END;
}


} // end anonymous namespace

} // namespace helpers_v3
} // namespace s_breguisvc
} // namespace BloombergLP
